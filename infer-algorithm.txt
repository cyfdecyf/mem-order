Processing each thread's write log to get write-after-read log

log form: [version before write, wait read thread id, read thread read memop]

For write-after-read logs, we know which specific write should wait. But to unify
the replay logic, we only use the above log form.

Process write log:
  while (logent = next write log ent)
    // Find all following writes by this thread to the logged object.
    // We get a version change region, no other thread writes the object
    // at these version.
    Find following version change range [Va, Vb]

    // objid is actually logent.objid
    for each version in version range [Va, Vb]
      Take write-after-read log

Find following version change range
  Params: version
  Output: biggest write version that's not modified by other thread

  for each other threads' write log
    search for smallest next write version that's larger than version
  return smallest write version by other threads - 1

Take write-after-read log:
  Params: version before write

  reads = Find all reads happen at specific version
  for each read in reads
    output log [version before write, read thread id, read thread read_memop]

Find all reads @version on objid:
  Params: version, except_thrid
  Output: All reads that get the specific version of the object

  result_vector = []
  for each thread
    if thrid == except_thrid
      continue
    result_vector.add(find read @version for objid on thread thrid)

Find read @version for objid on given thread:
  Params: version, objid, thread
  Output: read memop

  Search in logent_deque[objid] to see if there's any record with matching version
  if found, return the memop

  not found, we need to scan the read log to search
  while (logent = next read log ent in thread read log)
    if there's no previous read according to the log entry
      Store the log entry so later we can infer which version is the last read
      last_logent[objid] = logent
      continue

    prev_version = last_logent[objid].version

    if objid == logent.objid
      // we should not check the current logent's version,
      // there maybe read after this log that's actually hanged
      if prev_version == version
        the last read happens at the specific version
        return logent.last_read_memop
    else // objid != logent.objid
      Store last read's version and memop info for later reference
            logent_deque[objid].push_back(prev_version, log_ent.last_read_memop)

    last_logent[objid] = logent
